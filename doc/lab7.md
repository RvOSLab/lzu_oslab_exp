# Lab7

本实验所需源码可从 [lzu_oslab_exp 仓库](https://git.neko.ooo/LZU-OSLab/lzu_oslab_exp) 下载。

本实验的 step by step 文档可以访问 [Code an OS Project](https://lzu-oslab.github.io/step_by_step_doc/)。

这一节，我们将涉及到 TCP/IP 协议栈，参考 Linux 操作系统网络接口的架构，在 TCP/IP 协议栈的基础上，开发出 Socket 接口。主要功能包括 ARP 协议，IP 协议和 ICMP 协议，传输层 TCP 和 UDP 协议与在此接口上的一套 Socket 接口，包括 socket、bind、listen、accept 等一系列网络编程中常用的系统调用。

## TCP/IP 参考模型

TCP/IP参考模型是用来描述TCP/IP协议栈的一个抽象模型，此模型把计算机网络模块根据功能及数据在发送到网络前处理过程的传递顺序划分成几个“层”，每个层中包含完成该层功能的协议，计算机通过TCP/IP协议栈发送数据时，需要自顶向下使用每一层中的协议或者功能对数据进行处理，然后再发送到网络。接收数据时则需要自底向上对收到的数据包进行处理，最后再将最终的数据交给应用程序。接下来自顶向下对TCP/IP协议栈中的四个层进行一个简要的介绍：

- 应用层：该层主要包含应用程序为了实现自己特定的工作实现的协议，比如浏览器常用的HTTP协议，文件服务器常用的FTP协议和邮件服务器常用的STMP协议，这一层协议由应用程序实现，一般操作系统不提供支持。
- 传输层：传输层的协议主要为计算机提供端到端的通信能力，即应用程序到应用程序的通信，同时还能保证通信的可靠性，传输层主要的协议有TCP协议和UDP协议。
- 网络层：网络层协议实现了网络中主机到主机的通信。IP协议是网络层最重要，也是使用最多的协议。
- 网络访问层：主要对网络层的数据进行格式转换。由于网络适配器传输条件的限制，所以网络访问层软件必须对数据进行格式转换使其符合硬件的传输条件。

当应用程序用TCP（或UDP）传送数据时，数据被送入协议栈中，然后逐个通过TCP/IP协议栈中的每一层直到被通过硬件接口送入网络。协议栈中的每一层收到数据都要增加一些首部信息。
 
## sk_buff

sk_buff是网络接口开发中的一个重要数据结构，后续章节会多次提到，在此对其做一个简要的介绍。

在协议栈中，对于要发送的数据，需要自上而下进行一层层地封装，最后交给网络设备发送出去，而对于网络设备接收到的数据，需要一层层解开封装，将真正的数据交给应用层协议，这就需要一个满足以下条件的数据结构作为缓存区：

1. 数据结构的首尾能够以很小的代价添加或移除数据，因为协议栈中的每一层收到数据都要增加一些首部信息或尾部信息
2. 每个协议都应该很方便访问他们的头部；
3. 为了协议栈的效率，在添加和移除数据时能尽量避免数据的复制。

为了满足以上需求，我们参考Linux系统源码，设计并实现了sk_buff, sk_buff 是socket buffer的简写。

接下来针对sk_buff中的重要字段逐一进行解释：

- next和prev字段主要用于实现sk_buff链表；
- dev字段是一个存储网络设备信息的结构体，包括MAC地址、IP地址等；protocol字段表示此数据包所用的网络协议（TCP、UDP、ICMP等）；
- len字段用来表示已填充数据的大小，在数据封装过程中，数据以及各层的协议首部是逐层填充的，因此len字段的值会随着数据的传递动态变化；
- dlen字段用来表示数据的长度，即不包含协议首部（应用层协议除外）；
- seq和end_seq仅在protocol字段的值为TCP是有效用来表示此报文段的起始序列号和终止序列号。
- Packetdata是一个字节数组，用来存储真正的网络数据包，head、data和end均是用来指示Packetdata。

针对sk_buff，专门实现了alloc_skb函数，用来产生sk_buff，此过程会申请Packetdata空间并初始化sk_buff的各个字段，通常不允许直接定义sk_buff结构体类型的变量，sk_buff必须通过调用alloc_skb来生成，因此，sk_buff与Packetdata总是一一对应的。

## 网络访问层实现

网络访问层的实现主要分为两个部分：

一是以太网帧的封装和解封装，封装受网络层协议（主要是IP协议）的调用，网络层协议需要发送数据时，将要发送的数据发送给网络访问层，网络访问层需要对其进行进一步的封装，为其添加以太网帧首部，并转换成网络适配器能识别格式。解封装主要是在网络适配器收到数据时通过中断被调用，它将网络适配器收到的数据解封装，即去掉以太网帧首部后通过调用网络层协议的方法将数据交给网络层协议去处理。

二是ARP协议，ARP根据功能来看，更像是处于网络层和网络访问层中间的一种协议，它提供了从IP地址到MAC地址转换的能力。

### 以太网帧封装

以太网数据帧是以太网中传输数据的最小单位，简称以太帧。由于网络适配器传输条件的限制，网络访问层软件必须对数据进行格式转换使其符合硬件的传输条件。

#### 以太帧的工作机制

当网络层把数据传递给网络访问层后，网络访问层软件需要对其进行如下操作：

1. 为了符合以太网帧数据段的大小要求，需要将网络层较大的数据分解成较小的块。
2. 把分解后的数据块打包成以太网帧。除了数据之外，每一帧还包含目的MAC地址、源MAC地址等其他信息。
3. 把数据帧发送给网络适配器，网络适配器会把数据帧转换为比特流，并发送到网络。
4. 其他网络适配器接收到源地址的网络适配器发送的这个以太帧之后，会对以太帧中的目的地址进行检查。若检查通过则会把数据传递给网络层的协议进行处理。

#### 以太帧的结构

目的地址和源地址分别用来表示接收数据的网络适配器的地址和发送数据的网络适配器的地址。

类型用来表示该以太帧需要交给哪个上层进行处理。

数据即上层协议传递给网络访问层需要发送到网络的数据或者从网络中接收到的需要交给上层协议的数据，也称为有效荷载。

FCS，即帧检测序列，检测该帧是否出现差错，占 4 个字节。

我们根据以太帧的结构定义了结构体eth_hdr，用来进行以太帧的封装。

#### 封装和解封装

对于以太网帧的封装和解封装，本文实现了函数netdev_transmit和netdev_recv，netdev_transmit接受网络层的调用，会对网络传递的数据进行进一步的封装，也就是前文中提到的封装成以太帧，然后再发送给网络设备。网络设备接收到数据后会通过中断触发netdev_recv。netdev_recv会对网络设备收到的数据进行解封装，然后通过调用ip_rcv将解封装后的数据传递给网络层的IP协议。

### ARP协议的原理与实现

ARP （Address Resolution Protocol），即地址解析协议，由于网络层是通过IP地址在网络和主机之间通信，而网络访问层则是通过MAC进行通信的，所以在数据包由网络层到网络访问层需要一个网络协议，来进行由IP地址到MAC地址的转换，而承担这个责任的就是ARP协议，它是根据 IP 地址获取物理地址的一个 TCP/IP 协议，解决网络层和网络访问层的衔接问题。

#### ARP的工作原理

ARP的工作原理如下：

1. 网络中的每台主机都需要有一个ARP缓冲区 (ARP Cache)，其中主要保存的是一个名为 ARP表的数据结构，该表用来表示IP地址和MAC地址在网络中的对应关系。
2. 当源主机准备发送一个数据包到某一个目的主机的时候，它会先在自己的ARP缓冲区中的ARP表中查询是否有与目的IP地址对应的MAC地址，若有，就把要发送的数据包发送到此地址；否则，就通过广播向本地网段发起一个ARP请求的。
3. 由于发送的是广播，因此同一个网段中所有的主机都会收到这个ARP请求，收到请求的主机会检查请求中的IP地址是否与自身一致，若不一致，则直接丢弃该请求，否则向发起请求的主机发送ARP回应，其中包含自身的IP和MAC地址。同时，收到ARP请求的主机还会将ARP请求源主机的IP地址与MAC地址的对应关系存到自己的ARP表中。
4. 发起ARP请求的源主机在收到对应的主机发送的ARP响应数据包之后，会把其IP地址与MAC地址的对应关系添加到自己的ARP表中，并利用此对应关系向目的主机发送数据。若一直没有主机发送ARP相应，则表示本次ARP查询失败了。

#### ARP报文格式

ARP报文总长度为28字节，其中每个字段的含义如下：

- 硬件类型：用来表示硬件接口类型，最常用的以太网用 1来表示。
- 上层协议类型：表示ARP要转换的上层协议的地址类型。我们只对IPv4作了实现，它的值为 0x0800。
- 硬件地址长度和协议长度：分别指出本地硬件地址和上层协议地址的长度。
- 操作类型：用来表示这个报文的类型，ARP 请求为 1，ARP 响应为 2，RARP 请求为 3，RARP 响应为 4。我们只完成了ARP，因此，操作类型的值只有1和2。
- 源 MAC 地址和目标 MAC 地址：分别表示发送方设备和接收方设备的硬件地址。
- 源头IP 地址和目的地 IP 地址：分别表示发送方设备和接收方设备的 IP 地址。

我们根据ARP报文格式，设计了结构体arp_hdr和arp_ipv4，分别表示ARP报头和ARP数据。

#### ARP的实现

前文中提到过，每台主机都会在自己的ARP缓冲区 (ARP Cache)中建立一个 ARP列表，以表示IP地址和MAC地址的对应关系。我们中采用双向链表实现ARP表，每个ARP表项用结构体来存储。

根据ARP协议的工作原理，我们编写了一系列函数。下表是ARP中实现的所有函数及其功能简介。
 
| 函数名                       | 说明                                                  |
| ---------------------------- | ----------------------------------------------------- |
| arp_hdr                      | 用于获取从以太网帧中获取ARP头部                       |
| arp_entry_alloc              | 用于为ARP表项申请内存空间并构造ARP表项                |
| arp_alloc_skb                | 为ARP协议申请并构造sk_buff                            |
| insert_arp_translation_table | 在ARP表的尾部插入ARP表项                              |
| update_arp_translation_table | 判断是否需要更新ARP表                                 |
| arp_get_hwaddr               | 根据IP地址获取MAC地址，即在本机ARP表中进行MAC地址查询 |
| arp_init                     | 初始化ARP缓冲区，在系统启动时调用                     |
| free_arp                     | 释放ARP缓冲区，在系统关机时调用                       |
| arp_rcv                      | 用来接受ARP请求报文                                   |
| arp_reply                    | 根据ARP请求报文，对方请求的主机进行回复               |
| arp_request                  | 发送ARP请求                                           |

接下来对ARP中用到的几个核心函数arp_rcv、arp_reply和arp_request的具体实现进行简要介绍。

arp_rcv用来接收ARP请求报文，会被netdev_recv调用，前文讲netdev_recv函数时有过介绍。

arp_reply用于对收到的ARP请求发送响应，会被arp_rcv调用，arp_reply会构造一个ARP回复报文，包含自己的IP地址和MAC地址，再调用netdev_transmit发送给发起ARP请求的网络适配器。arp_reply逻辑较为简单，此处不再使用伪代码详细介绍。

arp_request用来发送ARP请求，IP协议要发送数据给某个IP地址时，会首先使用ARP协议查询其对应的MAC地址，若本地的ARP缓存中没有该IP地址对应的ARP表项，则需要调用arp_request发送ARP请求。

## 网络层的实现

网络层主要需要实现IP协议和ICMP协议。

IP协议是TCP/IP协议中最核心的协议之一，它主要提供了主机到主机的传输能力。传输层协议需要发送数据时，会调用IP协议，IP协议对传输层的数据进行封装，即添加了网络层传输需要用到的字段之后，再通过路由算法选择合适的路径后通过调用网络访问层提供的数据传输函数进行传输。当网络访问层收到数据时，会调用IP协议，IP协议将数据解封装后根据首部信息调用相应的传输层协议将数据传给传输层。

ICMP协议是用来辅助IP传输的，由于IP是无连接的非可靠传输，因此需要一种协议来发送差错信息，起这个作用的就是ICMP协议。与其他协议不同的是，ICMP协议会被多个层次的协议所调用，应用层协议，传输层协议以及网络层协议（即IP协议）均会调用ICMP协议。

需要注意的是，本文的IP协议和ICMP协议均是基于IPv4的，因此后文中提到的IP协议特指IPv4协议，ICMP协议特指ICMPv4协议。

### IP协议的原理与实现
IP(Internet Protocol)协议，即网际互连协议，在TCP/IP协议栈中承前启后的重要作用，为上一层提供服务，并接受下一层的调用。目前计算机中常用的TCP、UDP、ICMP及IGMP数据都是在IP基础上进行数据传输的。网际协议IP又称为Kahn-Cerf协议，因为这个重要协议正是Robert Kahn和Vint Cerf二人共同研发的，这两位学者在2005年获得图灵奖。

#### IP数据包格式

IP 数据报是IP 协议传输数据的最小单位，每个数据包都包含 IP 协议规定的内容。根据IP 协议规定，这些内容被称为 IP 数据报文（IP Datagram）或者 IP 数据报。

IP 数据报文包含两个部分，其中一部分是固定20字节长度的IP首部（称为报头），该部分是每一个IP数据报都要含有的，在其固定部分之后有一些长度可变的可选字段。另一部分是数据，即上层协议传递给IP协议需要发送到网络的数据或者从网络中接收到的需要交给上层协议的数据。

接下来对每个字段的含义进行解释：

- 版本（version）占 4 位，由于IP协议存在不同的版本且进行通信的两台主机必须使用相同版本的协议。因此用此字段来标识IP协议的版本。
- 首部长度（IHL）占 4 位，用来表示首部字段的长度，可表示的范围是0-15。此字段表示有多少个4字节长度（即32位字长）。所以，IP首部长度最长为60字节，即首部长度的值是15。由于此字段的单位是32位字长，所以IP首部字段所占的存储空间必须是4字节的整数倍，当不足4字节时，需要用0补齐。也由于这个原因，IP数据包的数据部分的起始位置永远是4的整数倍。
- 区分服务（tos）占 8 位，在旧标准中叫做服务类型，但实际的网络通信中一直没有被使用过。直到1998 年时， IETF 把这个字段的名字改为了Differentiated Services，即区分服务。这个字段才真正被使用。
- 总长度（totlen），即IP数据报的大小，由于该字段的大小时16位，所以IP数据报最大只能是65535字节。该字段的值是首部和数据的长度之和。
- 标识（identification）字段占 16 位，是用来标识数据报。主要用在数据报长度超过网络最大传输单元，需要进行分片时。
- 标志（flag）总共占 3 位。第二位表示是否允许分片，0和1分别表示允许和不允许，第三位用来表示是否还有分片需要传输，1表示有，0表示没有。第一位没有使用，该位的值应为0。
- 片偏移（offsetfrag）占 13 位。此字段和标识一样，主要用在数据报长度超过网络最大传输单元，需要进行分片时。报文被分片后，这个字段表示了分片在被分片报文中的相对位置。因为片偏移的偏移单位是8 个字节。所以，除了最后一个分片之外，其他所有分片的偏移值都是 8 字节（64 位）的整数倍。
- 生存时间（TTL）占 8 位，用来表示数据报在网络中的寿命。此字段最开始由发出数据报的源主机进行设置。它的目的是防止当数据报无法到达目的主机时在网络中无限制地一直传输，导致网络资源被消耗。网络中的节点每对数据报进行一次转发，都会把 TTL的 值减 1。当TTL的值为0时，则不再对其转发。 
- 协议占 8 位，用来表示该数据报文中所携带的数据所使用的上层协议的类型。常用的协议中，TCP 协议用6来表示，UDP 协议用17来表示，ICMP 协议用1来表示。
- 首部检验和（checksum）占 16 位，用于校验数据报的首部是否在传输的过程中发送了错误。因为首部字段TTL每经过一个路由器，其值都会被改变，所以路由器每一次转发IP数据报都需要重新计算校验和。
- 源地址和目的地址分别表示数据报的源头IP 地址和数据报的目的地IP 地址，占 32 位。
- 可选字段时一些可选的报头设置，这些设置主要被用于测试、安全和调试。由于报头长度需要保证是32位的整数倍，因此，当可选项长度不是32位的整数倍时，需要用若干个0填充。
- 数据部分表示传输层发送到IP协议的数据，或者从网络中接受到的数据，此部分的长度是可变的。 

我们根据IP数据包格式，设计了结构体iphdr，用来封装IP数据包。

#### IP发送数据包实现

IP协议接收上层协议需要发送的数据，然后进行封装后再交给网络访问层发送出去。为此，我们实现了函数int ip_output(struct sock *sk, struct sk_buff *skb)供上层协议调用。此处对其做简要介绍。

结构体sk_buff前文中已经介绍过了，它主要用来在协议栈的不同层次之间传递数据，且不需要拷贝。因此，函数 ip_output的形参skb中就包含了上层协议中需要发送的数据。结构体sock是传输层需要用的一个核心结构体，后文会详细讲解，此处主要是利用其netdev字段来指定IP首部的源地址。

函数ip_output首先会对上次协议传递的数据进行再次封装，为其添加IP首部。然后再将本机字节序转换为网络字节序，然后再计算出校验和。之后将封装好的IP数据包发送到网关，此处需要调用ARP协议来查询网关IP地址对应的MAC地址。

#### IP接收数据包实现

IP协议接收网路访问层硬件接口收到的数据，然后对其解封装后发送给其对应的上层协议处理。此外，我们实现了函数int ip_rcv(struct sk_buff *skb)供网络访问层的硬件接口调用。此处对其做简要介绍。

参数skb与IP数据发送中作用类似，主要用来传递数据，此处不再赘述。

函数ip_rcv首先会判断IP数据包的版本是否为IPv4，因为我们实现的协议栈仅支持IPv4，所以其他版本的IP数据包都会被丢弃，然后还需要依次判断IP首部长度，生存时间以及检验和是否合法，若不合法则直接丢弃，否则将根据首部字段协议来判断该数据包使用的上层协议，再调用对应的上层协议提供的方法将数据发送给上层协议进行进一步处理。

### ICMP协议的原理与实现

IP协议是无连接、无状态的数据报传输协议，它为计算机提供了一种尽力而为交付的主机到主机的数据传输能力。这样的IP协议就不可避免地会在数据的传输过程中出现一些故障，导致数据不能到达目的主机。为了在这种情况下让数据的发送方知道出现的问题，以便采取措施来避免或纠正，TCP/IP协议栈引入了ICMP（Internet Control Message Protocol）协议，即网际控制报文协议。

ICMP协议数据的传输需要借助IP协议，是对IP协议的一个补充。ICMP协议主要被用来报告IP协议在数据报传输的过程中产生的错误信息，报文分为很多类，其中回显请求和回显请求应答是最常用的。计算机中常用的ping命令，就采用ICMP回应请求和应答报文。

ICMP是一种无连接、无状态的协议，不同的报文共有15种，这些报文被分为两大类，第一类是差错报告，主要用来报告IP协议在数据报传输的过程中产生的错误信，还有一类是查询报告，这一类中最常用的就是前文中提到的回显请求，主要用来反映一台主机和另一台主机之间是否能通过IP通信，及其通信路径的路由信息。

#### ICMP报文格式

ICMP报文分为两部分，一部分是报头，报头包含了校验和、代码、类型这些传输过程中的控制信息。对其各字段详细解释如下：

- 类型：8bit，用于定义ICMP报文类型。
- 代码：用来表示为什么要发送这个报文，即发生了什么事。
- 校验和：用来检验数据包是否在传输过程中出现了差错。
- 报头其他部分：这部分不同的报文类型有不同的内容，在大部分报文这个此字读未被使用。
- 数据：这个字段的具体内容也由报文类型决定，不同的报文型类其内容也不同。

我们根据ICMP报文结构，设计了结构体icmp_v4、icmp_v4_echo和icmp_v4_dst_unreachable，分别表示ICMP通用报文、ICMP回显请求报文和ICMP端口不可达报文。

#### ICMP的实现

我们实现了ICMP中最常用的三种操作——回显请求、回显请求应答和端口不可达。

回显请求会向网络中的一个节点（路由器或者主机）发送一个回显请求报文（其类型字段的值为8），如果此报文成功到达目的主机或路由器，及途中没有发生异常，收到此报文的目的主机（或路由器）会发送一个回显请求响应报文（其类型字段值为0）给源主机（或路由器）。本文完成了函数icmpv4_echo_request和icmpv4_reply来完成ICMP的这两个操作。

端口不可达主要是给上层UDP协议使用，当UDP收到一个来自网络的数据报，而此数据包的目的端口没有正在监听，则UDP需要给源主机的源端口号发送一个ICMP端口不可达报文。此操作由函数icmpv4_port_unreachable来完成。因为端口不可达报文需要包含UDP报文的前8个字节，也就是源端口和目的端口号，因此，函数icmpv4_port_unreachable需要包含UDP报文的sk_buff作为参数。关于UDP报文格式以及端口号会在后文详细讲解。icmpv4_port_unreachable的伪代码表示如下：

## 传输层的实现

网络层提供了从主机到主机的传输能力，这种传输称为点到点传输。借助网络层，网络中的一台主机，可以向其他任意主机发送数据。如果相互通信的两个主机上都只运行一个应用程序，那么网络层可以工作的很好，但在大多数情况下，一个主机上运行着不止一个应用程序，因此，需要一种从进程到进程的传输能力。

为了实现从进程到进程的传输能力，在网络层的基础上，引入了新的传输层，专注于进程间通信。传输层的通信单元一般叫做段（segment），也分为头部和数据两个部分。其中，头部会保存发送进程和接收进程相关联的端口号。端口是传输层为了区分不同的通信端点而引入的概念。如果将主机想象成一栋建筑物，那么端口就像是它上面的房间门。一台主机上可以有很多个通信端口，应用进程可以关联到一个或多个端口。当进程需要发送数据时，它必须申请一个端口，数据从该端口发送出去；当某个端口有数据到达时，操作系统负责将数据提交给对应的应用进程。这种从进程到进程的传输能力，可以叫做端到端传输。我们可以通过主机地址，比如 IP 地址，来确定一个点，主机地址加上端口，则可以确定一个端。
传输层的通信单元是段（segment），它负责封装数据和通信双方的端口号。段需要借助网络层提供的点对点通信能力，由网络层包（比如 IP 包）携带，传输到目标主机。当段到到目标主机后，操作系统可以根据端口号，将数据提交给对应的进程。

在现行的 TCP/IP 协议栈中，有两个常用的传输层协议：

- UDP ，无连接的数据报式协议；
- TCP ，面向连接的流式协议。

### 套接字

前文中提到，传输层提出了端口的概念，为计算机提供了端到端，即应用程序到应用程序的通信能力，而套接字（Socket）则可以认为是对端到端通信线路的抽象，一个套接字必须包含以下信息：源主机IP地址，源端口号，目的主机IP地址，目的端口号以及发送数据用到的协议。由以上的信息，套接字就可以描述一个端到端的通信线路。

套接字需要提供一系列的调用接口，让应用程序（或者说应用层协议）可以较为方便地操控TCP和UDP来进行数据得传输。从这角度看，也可以认为套接字是存在于传输层和应用层之间，调用传输层协议为应用层协议提供服务。套接字创建时需要指定传输层使用的协议，主要是TCP和UDP。

我们在实现TCP/IP协议栈的基础上，完成了一套套接字接口：
 
| 函数名   | 说明                                                                         |
| -------- | ---------------------------------------------------------------------------- |
| socket   | 创建套接字                                                                   |
| connect  | “连接”远端服务器（仅用于客户端）                                             |
| close    | 释放/关闭套接字                                                              |
| bind     | 绑定套接字的本地IP地址和端口号（通常客户端不需要）                           |
| listen   | 配置服务端TCP套接字为监听模式，并设置队列大小（仅用于服务器端TCP套接字）     |
| accept   | 接受/提取一个连接请求，创建新套接字，通过新套接（仅用于服务器端的TCP套接字） |
| read     | 接收数据（用于TCP套接字或连接模式的客户端UDP套接字）                         |
| recvfrom | 接收数据报（用于非连接模式的UDP套接字）                                      |
| write    | 发送数据（用于TCP套接字或连接模式的客户端UDP套接字）                         |
| sendto   | 发送数据报（用于非连接模式的UDP套接字）                                      |

### TCP协议

TCP协议，英文全称为Transmission Control Protocol，即传输控制协议，是一种面向连接的、可靠的、基于字节流的传输层通信协议。TCP协议在实现端到端通信能力的基础上，还通过确认和超时重传实现了可靠传输、通过设置窗口大小实现了流量控制和拥塞控制等功能。

由于TCP是面向连接的，所以它还使用三次握手和四次挥手机制防止了连接被错误的建立、一段断开连接时，另一端还在发送数据或等待数据的接受等错误情况的发生。 

#### TCP报文格式

TCP 报文是 TCP 层传输的数据单元，也称为报文段。

每个字段的含义：

- 源端口号和目的端口号：分别用来表示发送方计算机上应用程序和接收方计算机上应用程序对应的端口号。
- 序列号：占 32 位，用来表示这个报文段发送的数据的第一个字节的编号。序列号是TCP实现可靠传输最关键的字段之一。
- 确认号：占 32 位，主要用在确认报文中，它表示的是接收方下一个期望收到的发送方发送的报文段的序列号，这也就代表着此序列号之前的报文已成功有序地接收。确认号在TCP实现可靠传输功能中起着重要作用。
- 数据偏移：指数据部分与报文段起始地址的相对距离。这个字段的值也代表了TCP首部的长度。
- 保留（Reserved）：占 4 位。目前没有被使用，值为0。
- 标志位字段： CWR、ECE、URG、ACK、PSH、RST、SYN、FIN这八个字段每个字段占1位，用来存储一些标志信息。其中ACK用来表示确认号字段是否有效，值为1时表示有效，为0时表示无效。SYN主要用在建立连接时，后文会在TCP三次握手时详细介绍。FIN主要用在释放连接数，会在后文四次挥手处详细介绍。
- 窗口大小：占 16 位，它用来表示从当前确认号算起，TCP缓冲区还能接收多少字节的数据。窗口大小时TCP实现流量控制和拥塞控制的重要字段。
- 校验位：占 16 位。用来检查TCP报文是否在传输中出现了差错，发送方会对TCP报文进行校验，计算出一个校验值，接收方收到TCP报文后会再次进行计算，得到一个校验值，当这个两个值相等时表示传输过程中没有出现差错，即报文是有效的，否则则说明报文在传输过程中出现了差错，报文就会被丢弃。
- 紧急指针：用来指出本报文中需要紧急处理的字节，只有标志位中的URG为1时，此字段才有效。 
- 可选项：和IP报文中的可选项一样，长度不定，但长度必须是 32bits 的整数倍，对此，原理和IP报文中的可选项一样，此处不再解释。

我们根据TCP协议的报文格式，设计了结构体tcphdr。

#### TCP 三次握手与四次挥手

由于TCP 是面向连接的协议，为了避免TCP连接被错误的建立，TCP协议规定TCP在建立连接时，通信双方必须在进行“三次握手”之后才能顺利建立连接。

- 第1次握手时，客户端首先要任选一个随机数x作为序列号，然后再向服务器发送 SYN 报文（SEQ=x，SYN=1），发送SYN报文后客户端进入 SYN_SENT 状态，等待接收服务器发送的确认。
- 第2次握手分为SYN报文和ACK报文两部分来完成的，即请求和确认报文。
  - 在收到了客户端的建立连接请求之后，服务端首先要发送确认，即向客户端发送一个确认号为ACK=x+1的确认报文。
  - 发送完确认之后，服务器还要向客户端发送一个连接请求，即SYN报文，发送完成后，服务器进入 SYN_RECV 状态等待第三次握手。
- 第3次握手，客户端在收到服务器的确认报文和连接请求报文后，还需要对服务端的连接请求进行确认。客户端确认之后进入ESTABLISHED 状态，服务器在收到客户端的确认之后也进入 ESTABLISHED 状态，完成 3 次握手。

为了避免TCP一端释放了连接而一端还在等待或者发送数据，使TCP的通信双方能同步释放连接，TCP协议规定TCP连接在释放时通信双方需要进行“四次挥手”。

- 第1次挥手，客户端在己方数据发送完之后，随机生成一个序列号x，然后向服务器端发送FIN 报文，表示己方数据已经发送完成，需要断开 TCP 连接。
- 第2次挥手：服务端收到客户端发送的断开连接请求之后，对其发出确认，此时TCP处于半关闭状态（CLOSE-WAIT），服务端能向客户端发送数据但是客户端不能向服务端发送数据。
- 第3次挥手：当服务端不再需要连接时，即服务端的数据已全部发送完成后，向客户端发送FIN=1的连接释放报文。
- 第4次挥手：客户端收到服务端发送的断开连接请求后对其发出确认，进入TIME-WAIT状态，等待2MSL（最大报文存活时间）后释放连接

#### timer

TCP中会在多处用到计时器，比如，超时重传设置超时时间，四次挥手断开连接时最后一次挥手需要等带2MSL后释放连接。因此，本文专门为TCP设计了一个计时器timer。timer是一个结构体，同时还有配套的一些函数。

对timer各个字段的含义解释如下：

- next和prev字段主要用来实现链表；
- refcnt是引用计数，表示当前有多少个指针指向此计时器，释放计时器时，需要判断refcnt是否为0；
- expires是过期时间，当系统时间大于或等于此字段的值时，则调用处理函数，即handler。
- cancelled表示此计时器是否被取消，此字段为真时，计时器到时后不会执行处理函数。
- handler是指向处理函数的指针，计时器到时会执行此函数。
- arg是处理函数的参数。

除了timer结构体外，本文还设置了一个全局变量tick，此变量的值会在系统启动时初始化为0，然后开始累加，其值约每100ms会被加一。

为了实现计时器功能，本文还完成了下列函数：

| 函数名         | 说明                                     |
| -------------- | ---------------------------------------- |
| timer_add      | 添加一个计时器                           |
| timer_release  | 释放一个计时器                           |
| timer_cancel   | 取消计时器，即计时器到时后不调用处理函数 |
| timers_start   | 计时器启动，此函数在系统启动时被调用     |
| timers_tick    | tick每次加一时会调用此函数               |
| timer_get_tick | 获取系统当前时间                         |

实现timer功能的核心函数是timers_tick，它会在每次tick的值加一时被调用，timers_tick会遍历timer链表，判断每一个计时器是否到时，若到时，则调用其处理函数并将其cancelled的值改为1。当一个计时器的refcnt的值为0且cancelled的值为1时，timers_tick会释放此计时器。

#### TCP的实现

本文为完成TCP，共完成函数四十余个，下表中选取了其中比较重要的做了列举和介绍。

| 函数名                           | 说明                                  |
| -------------------------------- | ------------------------------------- |
| tcp_read                         | 从指定的TCP连接中读取数据             |
| tcp_write                        | 向指定TCP连接写入数据                 |
| tcp_recv_notify                  | 唤醒一个等待接收进程                  |
| tcp_close                        | 关闭一个TCP连接                       |
| tcp_init                         | 初始化TCP协议                         |
| tcp_clear_timers                 | 清除一个TCP连接上的计时器             |
| tcp_stop_retransmission_timer    | 停止一个TCP连接的超时重传计时器       |
| tcp_release_retransmission_timer | 释放一个TCP连接的超时重传计时器       |
| tcp_in                           | 被IP协议调用，用来接收TCP报文         |
| tcp_process                      | 被tcp_in调用，用来处理接收到的TCP报文 |
| tcp_send                         | 向指定的TCP连接发送数据报文           |
| tcp_receive                      | 接收指定TCP连接上的数据               |
| tcp_send_ack                     | 向指定的TCP连接发送确认               |
| tcp_checksum                     | 计算TCP数据报的校验和                 |
| tcp_reset_retransmission_timer   | 重置TCP超市重传计时器                 |

TCP中设计的函数较多，代码量较大，此处选择tcp_process做详细介绍，其余函数的详细实现可参见github中的以下文件：

```
net/tcp.c
net/tcp_output.c
net/tcp_input.c
net/tcp_sock.c
net/tcp_data.c
```

### UDP协议

UDP协议的英文全称是User Datagram Protocol， 即用户数据报协议，是一种传输层协议。在 TCP/IP 协议栈，它与 TCP 协议一样提供了端到端的通信能力，不同的是，UDP是一种无连接、无状态的协议。 

与TCP相比UDP似乎只是在IP协议的基础上利用到端口号，提供应用程序到应用程序的通信能力，没有可靠传输，流量控制，拥塞控制等高阶功能。而这既是UDP的缺点同时也是它的优点，由于没有这些功能，因此UDP报文在发送和接收时会少很多程序，这就导致与TCP相比，UDP的效率会高很多，在一些对可靠性要求不高，而追求效率的场景中，UDP是非常有用的。

#### UDP报文格式

每个 UDP 报文分为 UDP 报头和 UDP 数据区两部分。报头由 4 个 16 位长（2 字节）字段组成，分别说明该报文的源端口、目的端口、报文长度和校验值。

UDP 报文中每个字段的含义的简要解释：

- 源端口：占16位，用来表示发送方应用程序所使用的端口号。接收方应用程序收到报文后，可以根据此字段的值向发送方发送响应，与TCP不同的是，此字段的值是可选的，如果不写入，则可用0填充此字段。
- 目的端口：占16位，用来表示接收方应用程序使用的端口号。
- 长度：占16位，用来表示UDP数据包的长度，由于UDP报文首部为8字节，因此这个字段的值的范围是8-65535。
- 校验值：占16 位，用来检查数据在传输过程中是否出现差错。

我们根据UDP协议的报文格式，设计了结构体udphdr。

#### UDP的实现

和TCP相比，UDP没有拥塞控制，流量控制以及可靠传输等功能，只需要尽力传输，功能较为简单，且UDP没有状态，因此，UDP的实现也要简单很多。

| 函数名         | 说明                                  |
| -------------- | ------------------------------------- |
| udp_in         | 被IP协议调用，用来接收UDP报文         |
| udp_init       | 在系统启动时被调用，用来初始化UDP协议 |
| udp_alloc_sock | 申请空间并构造UDP sock                |
| udp_sock_init  | 初始化UDP sock                        |
| udp_alloc_skb  | 为UDP申请空间并构造sk_buff结构体      |
| udp_write      | 向一个UDP端口写入数据                 |
| udp_read       | 从一个UDP端口读出数据                 |
| udp_send       | 向一个UDP端口发送数据                 |
| udp_sendto     | 向一个未绑定远端端口的UDP端口发送数据 |
| udp_connect    | 连接UDP远端端口                       |
| udp_recvfrom   | 从一个未绑定远端端口的UDP端口接收数据 |
| udp_close      | 关闭UDP端口                           |

此处选择udp_read做详细介绍，其余函数的具体实现可以参考github上的以下文件：

```
net/udp.c
net/udp_sock.c
```
