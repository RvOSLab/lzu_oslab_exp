# 设备

## 扁平设备树

设备树节点间通过嵌套及引用操作来表示其层次和依赖关系。设备树的每个节点都可包含一组或多组属性，每组属性都可对应一个或多个值，其文本格式(节选)如下所示。

```dts
plic@c000000 {
	#interrupt-cells = <0x01>;
	#address-cells = <0x00>;
	riscv,ndev = <0x35>;
	reg = <0x00 0xc000000 0x00 0x210000>;
	interrupts-extended = <&cpu0_intc 0x0b &cpu0_intc 0x09>;
	interrupt-controller;
	compatible = "sifive,plic-1.0.0", "riscv,plic0";
};
```

其二进制格式通常在启动阶段被加载到内存的特定位置中供内核读取，结构示意图如下图所示。其中文件头包含设备树的文件大小、版本号以及各部分偏移量等信息；字符串表用于保存设备树中出现的字符串值，以节省存储空间；节点数据由节点和属性键值对构成，并使用不同的标签分隔开。

![设备树二进制格式结构示意图](./images/%E8%AE%BE%E5%A4%87%E6%A0%91%E4%BA%8C%E8%BF%9B%E5%88%B6%E6%A0%BC%E5%BC%8F%E7%BB%93%E6%9E%84%E7%A4%BA%E6%84%8F%E5%9B%BE.svg)

一次完整的设备树遍历过程如下图所示：

![设备树遍历过程流程图](./images/%E8%AE%BE%E5%A4%87%E6%A0%91%E9%81%8D%E5%8E%86%E8%BF%87%E7%A8%8B%E6%B5%81%E7%A8%8B%E5%9B%BE.svg)

## 设备发现

本系统通过解析设备树来进行设备发现，具体的发现过程如下：

1.	取得设备树所在的物理内存地址。在内核初始化时通过读取a1寄存器获得设备树的物理内存地址，并保存到变量中。
2.	将设备树映射到虚拟内存地址空间。由于操作系统内核处于S态，只能访问虚拟地址空间，因此要将设备树所在的物理内存区域映射到虚拟地址空间，使得内核可访问其内容。
3.	校验取得设备树各部分偏移量。由于设备树内部的整数使用大端模式存储，而RISC-V使用小端字节序，因此需要将偏移量由大端序转为小端序，才可得到正确的数值。
4.	遍历设备树。该阶段内核会根据设备间的依赖关系和加载顺序遍历匹配设备树的节点数据，寻找是否有匹配的设备驱动程序。由于大多数设备均依赖中断控制器，因此本系统设备发现的遍历过程设计为两个阶段：第一阶段寻找可用的中断控制器并加载其设备驱动，第二阶段寻找其他支持的设备并加载其驱动。
5.	对应驱动的初始化过程。在发现某个设备后，内核会为其分配一个设备结构体并初始化其内容。在设备结构体创建完成后，内核会将该结构体传递给匹配的设备驱动，以完成最终的设备初始化工作。
6.	设备注册。在驱动完成初始化工作后，会向内核注册设备，所有注册的设备将由内核统一管理。

## 设备管理

本内核使用设备结构体储存设备的基本信息，并在设备结构体中预留了父设备指针，用来标识设备所属的总线信息（未实现总线设备）。

在发现设备时，由驱动程序向内核请求为发现的设备分配唯一的设备号，以区分不同的设备。其中高32位为主设备号代表设备型号，由设备的驱动指定一个随机的整数值，避免不同设备型号间重复；低32位为副设备号，由操作系统自动分配，内核会查找并分配该型号设备第一个未被使用的副设备号，用于区分同型号的不同设备实例。

内核通过哈希表来组织和管理设备结构体。在完成设备号的分配后，操作系统内核将设备结构体放入哈希表中存储。当需要查找某个设备时，内核从注册设备的哈希表中进行搜索，并返回设备号一致的设备结构体。

## 设备接口

本内核将不同的设备按特性和使用方法分为块设备、字符设备、网络设备、实时时钟设备和中断控制器设备等不同的设备类型，并设计了不同的设备接口抽象。

## 具体设备(驱动)

### 块设备

本文中的块设备泛指可以固定的块大小读写的存储设备，由于具体硬件平台的限制，不同平台上支持的块设备各有千秋。以全志科技公司出品的D1-H处理器为例，其可选择的有SD卡、SPI NAND Flash、SPI NOR Flash三种块存储设备。

为了简化块设备的驱动实现，我们选择了QEMU提供的VirtIO-BLK作为基本的块设备，并为其编写了设备驱动程序。

VirtIO是一种通用的输入输出设备半虚拟化标准，它提供了存储设备、网络设备、终端、键盘和图形处理器等常见设备的抽象。该标准还约定了设备和设备驱动间的通信方法和通信协议。

目前VirtIO标准最新的版本号为1.1，其在上个版本(1.0)的基础上有所改进，允许设备和驱动间协商支持的特性，并增加了新的VirtQueue内存布局。本内核实现的VirtIO-BLK驱动同时兼容上述两个版本的VirtIO标准。

### 块缓冲区

由于块设备的响应速度不如内存等高速随机存取设备，且一般只能按固定大小的数据块进行读写，因此本操作系统在内存中构建了一个用于块设备的缓冲区。

本操作系统设计实现的块设备缓冲区提供带缓冲的块设备读写操作：上层文件系统可向块设备缓冲区提交读写请求，具体的请求和缓存操作由块设备缓冲区完成。

### 串口

本操作系统的字符设备选择了QEMU仿真的ns16550a设备。该设备为一款UART芯片仿真，该芯片具有硬件实现的先入先出（FIFO）缓冲区，有较好的性能，且有较好的兼容性和代表性。

# 文件系统

## 层次结构

本操作系统实现的文件系统采用多层设计。分别是系统调用支持、虚拟文件系统、索引节点缓冲区、具体文件系统、块设备缓冲区和块设备驱动。文件系统各层间的调用关系如下图所示：

![文件系统各层间的函数调用关系](./images/%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E5%90%84%E5%B1%82%E9%97%B4%E7%9A%84%E5%87%BD%E6%95%B0%E8%B0%83%E7%94%A8%E5%85%B3%E7%B3%BB.svg)

## 虚拟文件系统(VFS)

常见的文件系统有Linux的Minix文件系统，Ext2、Ext3和Ext4扩展文件系统家族；微软的FAT、FAT32和NTFS文件系统。由于不同文件系统其内部目录数据结构和文件存储方式的不同，其目录和文件读写方式也多种多样。为了隐藏具体文件系统的细节，方便统一管理所有的文件系统，本文实现了一个虚拟文件系统，提供统一的文件系统操作接口。具体文件系统只需要实现给出的操作函数集合的全部或一部分函数，就可以让虚拟文件系统获得对应具体文件系统的操作能力。

本操作系统实现的虚拟文件系统包含超级块、索引节点、目录项和文件信息描述符等多种数据结构，并实现了索引节点缓冲区。

## 具体文件系统实现

### 内存文件系统

为了屏蔽具体文件系统的细节，更好的了解虚拟文件系统的工作原理，本操作系统实现了一个简单的内存文件系统，其不支持文件的写操作，只支持目录结构的访问和文件的读操作。

该内存文件系统不依赖具体的块设备，所有数据只保存于内存中，不需要额外的块设备用于持久化保存。

### Minix文件系统

Minix文件系统源于Minix操作系统使用的文件系统。该文件系统由引导块、超级块、索引节点位图、数据区位图、索引节点区和数据区六部分组成，其磁盘布局如下图所示：

![Minix文件系统磁盘布局](./images/Minix%E6%96%87%E4%BB%B6%E7%B3%BB%E7%BB%9F%E7%A3%81%E7%9B%98%E5%B8%83%E5%B1%80.svg)

Minix文件系统将磁盘空间以1KB大小划分为磁盘块，其超级块位于第二个磁盘块上，第一个磁盘块为引导程序预留。超级块记录了Minix文件系统的基本信息，如文件大小限制、各部分起始位置，索引节点和数据区的数量等。

Minix文件系统的索引节点记录了文件的大小、类型、权限信息和对应的数据区等数据，并有一个唯一的索引节点号与之对应。

Minix文件系统的数据区位于索引节点区后面，每个数据区对应的磁盘块数量为2的log_zone_size次幂，在1.0版本中log_zone_size的值为0，因此其数据区大小等于磁盘块大小。

为了更有效的存储文件内容，Minix文件系统的数据块组织采用三级设计，其在索引节点中记录了9个数据区索引。其中前7个为直接索引，第8个为二级索引，第9个为三级索引。

![数据区组织](./images/%E6%95%B0%E6%8D%AE%E5%8C%BA%E7%BB%84%E7%BB%87.svg)
